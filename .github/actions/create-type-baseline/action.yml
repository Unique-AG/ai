name: 'Create Type Baseline'
description: 'Creates a type checking baseline from a specified branch, supporting both Poetry and uv'

inputs:
  package_dir:
    description: 'Path to the package directory'
    required: true
  branch:
    description: 'Branch/ref to create baseline from'
    required: false
    default: 'main'
  package_manager:
    description: 'Package manager to use: auto (detect), poetry, or uv'
    required: false
    default: 'auto'
  python_version:
    description: 'Python version to use'
    required: false
    default: '3.11'
  package_manager_version:
    description: 'Package manager version to install (e.g., "1.8.3" for Poetry, ignored for uv)'
    required: false
    default: '1.8.3'
  output_file:
    description: 'Output file for baseline'
    required: false
    default: '/tmp/baseline.json'

runs:
  using: 'composite'
  steps:
    - name: Setup package manager
      id: setup_pm
      uses: ./.github/actions/install-package-manager
      with:
        package_dir: ${{ inputs.package_dir }}
        package_manager: ${{ inputs.package_manager }}
        python_version: ${{ inputs.python_version }}
        package_manager_version: ${{ inputs.package_manager_version }}

    - name: Save script before checkout
      shell: bash
      run: |
        # Copy script and lib to /tmp before checking out base branch
        # (otherwise we'd run main's version of the script, not the PR's)
        cp ${{ github.workspace }}/.github/scripts/create-type-baseline.sh /tmp/create-type-baseline.sh
        cp -r ${{ github.workspace }}/.github/scripts/lib /tmp/lib

    - name: Fetch base branch
      shell: bash
      run: git fetch origin ${{ inputs.branch }}:${{ inputs.branch }}

    - name: Checkout base branch
      shell: bash
      run: git checkout "origin/${{ inputs.branch }}" --quiet

    - name: Install dependencies on base branch
      shell: bash
      working-directory: ${{ inputs.package_dir }}
      run: |
        # Don't use --locked for base branch since older branches may not have
        # lock files that pass --locked validation
        INSTALL_CMD="${{ steps.setup_pm.outputs.install_cmd }}"
        if [[ "$INSTALL_CMD" == uv* ]]; then
          uv sync
        else
          $INSTALL_CMD
        fi

    - name: Discard lock file changes
      shell: bash
      run: |
        # Discard any changes to lock files from dependency installation
        # This prevents checkout errors when the script switches back to the PR branch
        if [ -f "${{ inputs.package_dir }}/poetry.lock" ]; then
          git restore "${{ inputs.package_dir }}/poetry.lock" 2>/dev/null || \
          git checkout -- "${{ inputs.package_dir }}/poetry.lock" 2>/dev/null || true
        fi
        if [ -f "${{ inputs.package_dir }}/uv.lock" ]; then
          git restore "${{ inputs.package_dir }}/uv.lock" 2>/dev/null || \
          git checkout -- "${{ inputs.package_dir }}/uv.lock" 2>/dev/null || true
        fi

    - name: Create baseline
      shell: bash
      working-directory: ${{ inputs.package_dir }}
      run: |
        # Use -c flag for CI mode. The script will checkout the base branch again
        # (redundant since we're already there), run basedpyright, then checkout back.
        # Lock files have been discarded, so checkout back should succeed.
        bash /tmp/create-type-baseline.sh \
          -c \
          -r "${{ steps.setup_pm.outputs.run_cmd }}" \
          -o "${{ inputs.output_file }}" \
          ${{ github.workspace }}/${{ inputs.package_dir }} \
          ${{ inputs.branch }}
