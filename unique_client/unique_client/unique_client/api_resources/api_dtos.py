# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-06-02T17:43:10+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, RootModel, constr


class ListObjectDto(BaseModel):
    object: str = Field(
        ..., description="Object type identifier for list responses", examples=["list"]
    )
    data: list[dict[str, Any]] = Field(..., description="Array of data items")


class ReferenceDto(BaseModel):
    name: str
    url: str | None = None
    sequence_number: float = Field(..., alias="sequenceNumber")
    source_id: str = Field(..., alias="sourceId")
    source: str


class Role(str, Enum):
    system = "SYSTEM"
    user = "USER"
    assistant = "ASSISTANT"


class PublicMessageDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(..., description="Object type identifier", examples=["message"])
    text: dict[str, Any] | None = Field(
        ...,
        description="Text content of the message",
        examples=["Hello, how can I help you today?"],
    )
    original_text: dict[str, Any] | None = Field(
        ...,
        alias="originalText",
        description="Original text before any processing",
        examples=["Hello, how can I help you today?"],
    )
    chat_id: dict[str, Any] | None = Field(
        ...,
        alias="chatId",
        description="ID of the chat this message belongs to",
        examples=["chat_123456789"],
    )
    role: Role = Field(..., description="Role of the message sender", examples=["user"])
    gpt_request: dict[str, Any] | None = Field(
        ...,
        alias="gptRequest",
        description="GPT request data associated with the message",
        examples=[{"model": "gpt-4", "temperature": 0.7}],
    )
    debug_info: dict[str, Any] | None = Field(
        ...,
        alias="debugInfo",
        description="Debug information for the message",
        examples=[{"processingTime": 1.5, "tokens": 150}],
    )
    completed_at: dict[str, Any] | None = Field(
        ...,
        alias="completedAt",
        description="Date when the message was completed",
        examples=["2023-12-06T10:05:00Z"],
    )
    created_at: dict[str, Any] | None = Field(
        ...,
        alias="createdAt",
        description="Date when the message was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    updated_at: dict[str, Any] | None = Field(
        ...,
        alias="updatedAt",
        description="Date when the message was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )
    references: list[ReferenceDto] | None = Field(
        None, description="References associated with the message"
    )


class PublicCreateMessageDto(BaseModel):
    chat_id: str = Field(..., alias="chatId")
    assistant_id: str = Field(..., alias="assistantId")
    original_text: str | None = Field(None, alias="originalText")
    text: str | None = None
    role: Role
    references: list[ReferenceDto] | None = Field(
        None, description="References belonging to the message"
    )
    gpt_request: dict[str, Any] | None = Field(None, alias="gptRequest")
    debug_info: dict[str, Any] | None = Field(None, alias="debugInfo")
    completed_at: datetime | None = Field(None, alias="completedAt")


class PublicUpdateMessageDto(BaseModel):
    chat_id: str = Field(..., alias="chatId")
    original_text: str | None = Field(None, alias="originalText")
    text: str | None = None
    references: list[ReferenceDto] | None = Field(
        None, description="References belonging to the message"
    )
    gpt_request: dict[str, Any] | None = Field(None, alias="gptRequest")
    debug_info: dict[str, Any] | None = Field(None, alias="debugInfo")
    completed_at: datetime | None = Field(None, alias="completedAt")


class DeletedObjectDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(..., description="Object type identifier", examples=["object"])
    deleted: bool = Field(
        ...,
        description="Indicates whether the object was successfully deleted",
        examples=[True],
    )


class FunctionDefinition(BaseModel):
    name: str = Field(..., description="The name of the function to be called.")
    description: str | None = Field(
        None, description="A description of what the function does."
    )
    parameters: dict[str, Any] | None = Field(
        None,
        description="The parameters the functions accepts, described as a JSON Schema object.",
    )


class JSONSchema(BaseModel):
    name: str = Field(
        ...,
        description="The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.",
    )
    description: str | None = Field(
        None,
        description="A description of what the response format is for, used by the model to determine how to respond in the format.",
    )
    schema_: dict[str, Any] | None = Field(
        None,
        alias="schema",
        description="The schema for the response format, described as a JSON Schema object.",
    )
    strict: bool | None = Field(
        None,
        description="Whether to enable strict schema adherence when generating the output.",
    )


class Type(str, Enum):
    text = "text"
    json_object = "json_object"
    json_schema = "json_schema"


class ChatCompletionsTextResponseFormat(BaseModel):
    type: Type
    json_schema: JSONSchema = Field(
        ..., description="The JSON Schema for the response format."
    )


class ChatCompletionsFunctionToolDefinition(BaseModel):
    type: str = Field(..., examples=["function"])
    function: FunctionDefinition


class ChatCompletionsNamedFunctionToolSelectionName(BaseModel):
    name: str = Field(..., description="The name of the function to call.")


class ChatCompletionsNamedFunctionToolSelection(BaseModel):
    type: str = Field(..., examples=["function"])
    function: ChatCompletionsNamedFunctionToolSelectionName


class FunctionCall(str, Enum):
    auto = "auto"
    none = "none"


class GetChatCompletionsOptions(BaseModel):
    functions: list[FunctionDefinition] | None = Field(
        None, description="A list of functions the model may generate JSON inputs for."
    )
    function_call: FunctionCall | None = Field(
        None, description="Controls how the model responds to function calls."
    )
    max_tokens: float | None = Field(
        None, description="The maximum number of tokens to generate."
    )
    temperature: float | None = Field(
        None,
        description="The sampling temperature to use that controls the apparent creativity of generated completions.",
    )
    top_p: float | None = Field(
        None,
        description="An alternative to sampling with temperature called nucleus sampling.",
    )
    logit_bias: dict[str, Any] | None = Field(
        None,
        description="A map between GPT token IDs and bias scores that influences the probability of specific tokens appearing in a completions response.",
    )
    user: str | None = Field(
        None, description="An identifier for the caller or end user of the operation."
    )
    n: float | None = Field(
        None,
        description="The number of chat completions choices that should be generated for a chat completions response.",
    )
    stop: list[str] | None = Field(
        None,
        description="A collection of textual sequences that will end completions generation.",
    )
    presence_penalty: float | None = Field(
        None,
        description="A value that influences the probability of generated tokens appearing based on their existing presence in generated text.",
    )
    frequency_penalty: float | None = Field(
        None,
        description="A value that influences the probability of generated tokens appearing based on their cumulative frequency in generated text.",
    )
    seed: float | None = Field(
        None,
        description="If specified, the system will make a best effort to sample deterministically.",
    )
    response_format: ChatCompletionsTextResponseFormat | None = Field(
        None,
        description="An object specifying the format that the model must output. Used to enable JSON mode.",
    )
    tools: list[ChatCompletionsFunctionToolDefinition] | None = Field(
        None,
        description="The available tool definitions that the chat completions request can use, including caller-defined functions.",
    )
    tool_choice: ChatCompletionsNamedFunctionToolSelection | None = Field(
        None,
        description="If specified, the model will configure which of the provided tools it can use for the chat completions response.",
    )


class FunctionCallDTO(BaseModel):
    pass


class ChatCompletionsToolCallDTO(BaseModel):
    type: str
    function: FunctionCallDTO
    id: str


class ChatResponseMessageDto(BaseModel):
    role: str
    content: str
    tool_calls: list[ChatCompletionsToolCallDTO]
    function_call: FunctionCallDTO


class StopFinishDetailsDto(BaseModel):
    type: str
    stop: str


class MaxTokensFinishDetailsDto(BaseModel):
    type: str


class ChatFinishDetailsDto(BaseModel):
    stop_finish_details: StopFinishDetailsDto
    max_tokens_finish_details: MaxTokensFinishDetailsDto


class ChatChoiceDto(BaseModel):
    message: ChatResponseMessageDto
    index: float
    finish_reason: str
    finish_details: ChatFinishDetailsDto
    delta: ChatResponseMessageDto


class CompletionsUsageDto(BaseModel):
    completion_tokens: float
    prompt_tokens: float
    total_tokens: float


class ChatCompletionsDtoOld(BaseModel):
    id: str
    created: datetime
    choices: list[ChatChoiceDto]
    system_fingerprint: str
    usage: CompletionsUsageDto


class CreateEmbeddingsRequestDto(BaseModel):
    texts: list[str] = Field(..., description="Array of texts to create embeddings for")


class EmbeddingsResultDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["embeddings"]
    )
    embeddings: list[list[float]] = Field(
        ...,
        description="Array of embedding vectors",
        examples=[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]],
    )


class HistoryMessage(BaseModel):
    pass


class PublicCreateSearchStringDto(BaseModel):
    prompt: str
    chat_id: str | None = Field(None, alias="chatId")
    messages: list[HistoryMessage] | None = None
    language_model: str | None = Field(None, alias="languageModel")


class PublicSearchStringDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["search.search-string"]
    )
    search_string: str = Field(
        ...,
        alias="searchString",
        description="The search string that was created",
        examples=["artificial intelligence machine learning"],
    )


class RerankerRequestDto(BaseModel):
    deployment_name: str = Field(..., alias="deploymentName")
    options: dict[str, Any] | None = None


class SearchType(str, Enum):
    vector = "VECTOR"
    combined = "COMBINED"


class PublicCreateSearchDto(BaseModel):
    chat_id: str | None = Field(None, alias="chatId")
    search_string: str = Field(..., alias="searchString")
    search_type: SearchType = Field(..., alias="searchType")
    scope_ids: list[str] | None = Field(None, alias="scopeIds")
    chat_only: bool | None = Field(None, alias="chatOnly")
    limit: float | None = None
    page: float | None = None
    meta_data_filter: dict[str, Any] | None = Field(None, alias="metaDataFilter")
    reranker: RerankerRequestDto | None = None
    language: str | None = None
    content_ids: list[str] | None = Field(None, alias="contentIds")


class NestedStringFilter(BaseModel):
    contains: str | None = Field(
        None,
        description="Filter condition that matches if the field contains the specified string.",
    )
    ends_with: str | None = Field(
        None,
        alias="endsWith",
        description="Filter condition that matches if the field ends with the specified string.",
    )
    equals: str | None = Field(
        None,
        description="Filter condition that matches if the field is equal to the specified string.",
    )
    gt: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than the specified string.",
    )
    gte: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than or equal to the specified string.",
    )
    in_: list[str] | None = Field(
        None,
        alias="in",
        description="Filter condition that matches if the field is within the specified list of strings.",
    )
    lt: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than the specified string.",
    )
    lte: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than or equal to the specified string.",
    )
    not_: NestedStringFilter | None = Field(
        None,
        alias="not",
        description="Negation of the current filter. Can be used to specify a condition that should not match.",
    )
    not_in: list[str] | None = Field(
        None,
        alias="notIn",
        description="Filter condition that matches if the field is not within the specified list of strings.",
    )
    starts_with: str | None = Field(
        None,
        alias="startsWith",
        description="Filter condition that matches if the field starts with the specified string.",
    )


class Mode(str, Enum):
    default = "default"
    insensitive = "insensitive"


class StringFilter(BaseModel):
    contains: str | None = Field(
        None,
        description="Filter condition that matches if the field contains the specified string.",
    )
    ends_with: str | None = Field(
        None,
        alias="endsWith",
        description="Filter condition that matches if the field ends with the specified string.",
    )
    equals: str | None = Field(
        None,
        description="Filter condition that matches if the field is equal to the specified string.",
    )
    gt: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than the specified string.",
    )
    gte: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than or equal to the specified string.",
    )
    in_: list[str] | None = Field(
        None,
        alias="in",
        description="Filter condition that matches if the field is within the specified list of strings.",
    )
    lt: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than the specified string.",
    )
    lte: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than or equal to the specified string.",
    )
    mode: Mode | None = Field(
        None, description="Specifies the mode for string comparison."
    )
    not_: NestedStringFilter | None = Field(
        None,
        alias="not",
        description="Filter condition for all properties except this one.",
    )
    not_in: list[str] | None = Field(
        None,
        alias="notIn",
        description="Filter condition that matches if the field is not within the specified list of strings.",
    )
    starts_with: str | None = Field(
        None,
        alias="startsWith",
        description="Filter condition that matches if the field starts with the specified string.",
    )


class NestedStringNullableFilter(BaseModel):
    contains: str | None = Field(
        None,
        description="Filter condition that matches if the field contains the specified string.",
    )
    ends_with: str | None = Field(
        None,
        alias="endsWith",
        description="Filter condition that matches if the field ends with the specified string.",
    )
    equals: str | None = Field(
        None,
        description="Filter condition that matches if the field is equal to the specified string.",
    )
    gt: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than the specified string.",
    )
    gte: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than or equal to the specified string.",
    )
    in_: list[str] | None = Field(
        None,
        alias="in",
        description="Filter condition that matches if the field is within the specified list of strings.",
    )
    lt: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than the specified string.",
    )
    lte: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than or equal to the specified string.",
    )
    not_: NestedStringNullableFilter | None = Field(
        None,
        alias="not",
        description="Negation of the current filter. Can be used to specify a condition that should not match.",
    )
    not_in: list[str] | None = Field(
        None,
        alias="notIn",
        description="Filter condition that matches if the field is not within the specified list of strings.",
    )
    starts_with: str | None = Field(
        None,
        alias="startsWith",
        description="Filter condition that matches if the field starts with the specified string.",
    )


class StringNullableFilter(BaseModel):
    contains: str | None = Field(
        None,
        description="Filter condition that matches if the field contains the specified string.",
    )
    ends_with: str | None = Field(
        None,
        alias="endsWith",
        description="Filter condition that matches if the field ends with the specified string.",
    )
    equals: str | None = Field(
        None,
        description="Filter condition that matches if the field is equal to the specified string.",
    )
    gt: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than the specified string.",
    )
    gte: str | None = Field(
        None,
        description="Filter condition that matches if the field is greater than or equal to the specified string.",
    )
    in_: list[str] | None = Field(
        None,
        alias="in",
        description="Filter condition that matches if the field is within the specified list of strings.",
    )
    lt: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than the specified string.",
    )
    lte: str | None = Field(
        None,
        description="Filter condition that matches if the field is less than or equal to the specified string.",
    )
    mode: Mode | None = Field(
        None, description="Specifies the mode for string comparison."
    )
    not_: NestedStringNullableFilter | None = Field(
        None,
        alias="not",
        description="Filter condition for all properties except this one.",
    )
    not_in: list[str] | None = Field(
        None,
        alias="notIn",
        description="Filter condition that matches if the field is not within the specified list of strings.",
    )


class ContentWhereInput(BaseModel):
    and_: list[ContentWhereInput] | None = Field(
        None, alias="AND", description="Logical AND on all conditions."
    )
    not_: list[ContentWhereInput] | None = Field(
        None, alias="NOT", description="Logical NOT on all conditions."
    )
    or_: list[ContentWhereInput] | None = Field(
        None, alias="OR", description="Logical OR on all conditions."
    )
    id: StringFilter | None = Field(None, description="Filter by ID.")
    key: StringFilter | None = Field(None, description="Filter by key.")
    owner_id: StringFilter | None = Field(
        None, alias="ownerId", description="Filter by owner ID."
    )
    title: StringNullableFilter | None = Field(None, description="Filter by title.")
    url: StringNullableFilter | None = Field(None, description="Filter by URL.")


class SearchDto(BaseModel):
    where: ContentWhereInput | None = Field(
        None, description="Filters to apply on the content search."
    )
    chat_id: str | None = Field(
        None, alias="chatId", description="The chat ID related to the search query."
    )


class PublicContentDto(BaseModel):
    id: str = Field(
        ...,
        description="Unique identifier for the content",
        examples=["content_123456789"],
    )
    object: str = Field(..., description="Object type identifier", examples=["content"])
    key: str = Field(
        ..., description="Unique key for the content", examples=["document.pdf"]
    )
    url: str | None = Field(
        ...,
        description="URL of the content",
        examples=["https://example.com/document.pdf"],
    )
    title: str | None = Field(
        ..., description="Title of the content", examples=["Important Document"]
    )
    mime_type: str | None = Field(
        ...,
        alias="mimeType",
        description="MIME type of the content",
        examples=["application/pdf"],
    )
    metadata: dict[str, Any] | None = Field(
        ...,
        description="Metadata associated with the content",
        examples=[{"author": "John Doe", "tags": ["important", "document"]}],
    )
    created_at: datetime = Field(
        ...,
        alias="createdAt",
        description="Date when the content was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    updated_at: datetime = Field(
        ...,
        alias="updatedAt",
        description="Date when the content was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )
    read_url: str | None = Field(
        None,
        alias="readUrl",
        description="Read URL for accessing the content",
        examples=["https://example.com/read/document.pdf"],
    )
    chunks: list[dict[str, Any]] = Field(..., description="Chunks of the content")
    ingestion_state: str = Field(
        ...,
        alias="ingestionState",
        description="Current ingestion state of the content",
        examples=["COMPLETED"],
    )


class ContentInfoDto(BaseModel):
    metadata_filter: dict[str, Any] = Field(
        ...,
        alias="metadataFilter",
        description="UniqueQL metadata filters to apply on the content search.",
    )
    take: float = Field(..., description="The number of results to return.")
    skip: float = Field(..., description="The number of results to skip.")


class PublicContentInfoDto(BaseModel):
    id: str = Field(
        ...,
        description="Unique identifier for the content",
        examples=["content_123456789"],
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["content-info"]
    )
    key: str = Field(
        ..., description="Unique key for the content", examples=["document.pdf"]
    )
    url: dict[str, Any] | None = Field(
        ...,
        description="URL of the content",
        examples=["https://example.com/document.pdf"],
    )
    title: dict[str, Any] | None = Field(
        ..., description="Title of the content", examples=["Important Document"]
    )
    mime_type: dict[str, Any] | None = Field(
        ...,
        alias="mimeType",
        description="MIME type of the content",
        examples=["application/pdf"],
    )
    metadata: dict[str, Any] | None = Field(
        ...,
        description="Metadata associated with the content",
        examples=[{"author": "John Doe", "tags": ["important", "document"]}],
    )
    created_at: datetime = Field(
        ...,
        alias="createdAt",
        description="Date when the content was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    updated_at: datetime = Field(
        ...,
        alias="updatedAt",
        description="Date when the content was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )


class PublicContentInfoResponseDto(BaseModel):
    content_info: list[PublicContentInfoDto] = Field(
        ..., alias="contentInfo", description="Array of content information"
    )
    total_count: float = Field(
        ...,
        alias="totalCount",
        description="Total count of content items",
        examples=[42],
    )


class CustomApiOptionsDto(BaseModel):
    api_identifier: str = Field(..., alias="apiIdentifier")
    api_payload: str | None = Field(None, alias="apiPayload")
    customisation_type: str = Field(..., alias="customisationType")


class VttConfigDto(BaseModel):
    language_model: str | None = Field(None, alias="languageModel")


class IngestionConfigDto(BaseModel):
    chunk_max_tokens: float | None = Field(None, alias="chunkMaxTokens")
    chunk_max_tokens_one_pager: float | None = Field(
        None, alias="chunkMaxTokensOnePager"
    )
    chunk_min_tokens: float | None = Field(None, alias="chunkMinTokens")
    chunk_strategy: str | None = Field(None, alias="chunkStrategy")
    custom_api_options: list[CustomApiOptionsDto] | None = Field(
        None, alias="customApiOptions"
    )
    document_min_tokens: float | None = Field(None, alias="documentMinTokens")
    excel_read_mode: str | None = Field(None, alias="excelReadMode")
    jpg_read_mode: str | None = Field(None, alias="jpgReadMode")
    pdf_read_mode: str | None = Field(None, alias="pdfReadMode")
    ppt_read_mode: str | None = Field(None, alias="pptReadMode")
    unique_ingestion_mode: str | None = Field(None, alias="uniqueIngestionMode")
    vtt_config: VttConfigDto | None = Field(None, alias="vttConfig")
    word_read_mode: str | None = Field(None, alias="wordReadMode")


class ContentUpsertInputDto(BaseModel):
    key: str
    title: str
    mime_type: str = Field(..., alias="mimeType")
    byte_size: float | None = Field(None, alias="byteSize")
    url: str | None = None
    ingestion_config: IngestionConfigDto | None = Field(None, alias="ingestionConfig")
    metadata: dict[str, Any] | None = None


class ContentUpsertDto(BaseModel):
    input: ContentUpsertInputDto
    scope_id: str | None = Field(None, alias="scopeId")
    chat_id: str | None = Field(None, alias="chatId")
    store_internally: bool | None = Field(None, alias="storeInternally")
    file_url: str | None = Field(None, alias="fileUrl")


class PublicContentUpsertMutationDto(BaseModel):
    id: str = Field(
        ...,
        description="Unique identifier for the content",
        examples=["content_123456789"],
    )
    object: str = Field(..., description="Object type identifier", examples=["content"])
    key: str = Field(
        ..., description="Unique key for the content", examples=["document.pdf"]
    )
    url: dict[str, Any] | None = Field(
        ...,
        description="URL of the content",
        examples=["https://example.com/document.pdf"],
    )
    title: dict[str, Any] | None = Field(
        ..., description="Title of the content", examples=["Important Document"]
    )
    mime_type: dict[str, Any] | None = Field(
        ...,
        alias="mimeType",
        description="MIME type of the content",
        examples=["application/pdf"],
    )
    metadata: dict[str, Any] | None = Field(
        ...,
        description="Metadata associated with the content",
        examples=[{"author": "John Doe", "tags": ["important", "document"]}],
    )
    updated_at: datetime = Field(
        ...,
        alias="updatedAt",
        description="Date when the content was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )
    read_url: dict[str, Any] | None = Field(
        None,
        alias="readUrl",
        description="Read URL for accessing the content",
        examples=["https://example.com/read/document.pdf"],
    )
    write_url: dict[str, Any] | None = Field(
        None,
        alias="writeUrl",
        description="Write URL for uploading content",
        examples=["https://example.com/write/document.pdf"],
    )


class TableColumnDto(BaseModel):
    name: str = Field(..., description="The name of the column.")
    type: str = Field(..., description="The data type of the column.")
    identifying: bool = Field(
        False,
        description="Indicates whether the column is an identifying attribute of the table.",
    )
    displayed: bool = Field(
        True, description="Indicates whether the column is displayed in the table."
    )


class TableConfigDto(BaseModel):
    table_file_name: str = Field(
        ...,
        alias="tableFileName",
        description="The file name of the table configuration.",
    )
    columns: list[TableColumnDto] = Field(
        ..., description="An array of column configurations for the table."
    )
    row_filter: str = Field(
        ...,
        alias="rowFilter",
        description="A filter string to apply to the rows of the table.",
    )
    repeating_table: str = Field(
        ...,
        alias="repeatingTable",
        description="The name of the repeating table structure.",
    )
    header: str = Field(..., description="The header content for the table.")
    footer: str = Field(..., description="The footer content for the table.")
    no_data_found: str = Field(
        ...,
        alias="noDataFound",
        description="The message displayed when no data is found for the table.",
    )


class QueryTableRequest(BaseModel):
    query: str = Field(
        ...,
        description="The SQL query string to be executed for retrieving table data.",
    )
    table_config: TableConfigDto = Field(
        ...,
        alias="tableConfig",
        description="The configuration object for the table that includes columns, filters, and other settings.",
    )


class QueryTableAnswertDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["queryTableAnswer"]
    )
    markdown: str = Field(
        ...,
        description="Markdown formatted answer from the table query",
        examples=[
            "| Column 1 | Column 2 |\n|----------|----------|\n| Value 1  | Value 2  |"
        ],
    )
    selected: list[dict[str, Any]] = Field(
        ...,
        description="Selected data from the table query",
        examples=[[{"id": 1, "name": "Item 1"}, {"id": 2, "name": "Item 2"}]],
    )
    cleaned_query: str = Field(
        ...,
        alias="cleanedQuery",
        description="Cleaned and processed query string",
        examples=["SELECT * FROM table WHERE condition = true"],
    )


class ExcelExportRequestDto(BaseModel):
    template_name: str = Field(
        ...,
        alias="templateName",
        description="The name of the template to be used for the export.",
    )
    scope_id: str = Field(
        ...,
        alias="scopeId",
        description="The identifier of the scope within which the export is performed.",
    )
    data: dict[str, Any] = Field(
        ..., description="The data to be included in the export."
    )
    resulting_filename: str = Field(
        ...,
        alias="resultingFilename",
        description="The filename that will be used for the resulting exported file.",
    )


class ExcelExportResultDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["excel-export"]
    )
    name: str = Field(
        ...,
        description="Name of the exported Excel file",
        examples=["export_data_2023-12-06.xlsx"],
    )
    url: str = Field(
        ...,
        description="URL to download the exported Excel file",
        examples=["https://example.com/exports/export_data_2023-12-06.xlsx"],
    )
    source_id: str = Field(
        ...,
        alias="sourceId",
        description="ID of the source used for the export",
        examples=["source_123456789"],
    )
    source: str = Field(
        ...,
        description="Name of the source used for the export",
        examples=["Content Database"],
    )


class SearchResultDto(BaseModel):
    id: str = Field(..., description="Unique identifier for the search result.")
    chunk_id: str = Field(
        ...,
        alias="chunkId",
        description="Identifier of the chunk containing the search result.",
    )
    key: str = Field(..., description="Key associated with the search result.")
    title: str | None = Field(None, description="Title of the search result.")
    url: str | None = Field(None, description="URL of the search result.")
    internally_stored_at: datetime | None = Field(
        None,
        alias="internallyStoredAt",
        description="Timestamp when the search result was stored internally.",
    )


class PublicToolCallDto(BaseModel):
    id: str = Field(
        ...,
        description="Unique identifier for the tool call",
        examples=["call_123456789"],
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["toolCall"]
    )
    name: dict[str, Any] | None = Field(
        ..., description="Name of the tool being called", examples=["search_documents"]
    )
    arguments: dict[str, Any] | None = Field(
        ...,
        description="Arguments passed to the tool call",
        examples=['{"query": "artificial intelligence", "limit": 10}'],
    )


class PublicStreamResultDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["streamResult"]
    )
    message: PublicMessageDto = Field(
        ..., description="The message result from the stream completion"
    )
    tool_calls: list[PublicToolCallDto] = Field(
        ...,
        alias="toolCalls",
        description="Tool calls made during the stream completion",
    )


class ShortTermMemoryDto(BaseModel):
    memory_name: str = Field(..., alias="memoryName")
    chat_id: str | None = Field(None, alias="chatId")
    message_id: str | None = Field(None, alias="messageId")
    data: constr(max_length=10000)


class ShortTermMemoryResultDto(BaseModel):
    id: str = Field(
        ...,
        description="Unique identifier for the short-term memory entry",
        examples=["memory_123456789"],
    )
    object: str = Field(..., description="Object type identifier", examples=["message"])
    chat_id: dict[str, Any] | None = Field(
        ...,
        alias="chatId",
        description="ID of the chat this memory belongs to",
        examples=["chat_987654321"],
    )
    message_id: dict[str, Any] | None = Field(
        ...,
        alias="messageId",
        description="ID of the message this memory is associated with",
        examples=["message_456789123"],
    )
    data: str = Field(
        ...,
        description="Data stored in the short-term memory",
        examples=["User preferences: dark mode enabled, language: English"],
    )


class ShortTermMemoryRequestDto(BaseModel):
    memory_name: str = Field(..., alias="memoryName")
    chat_id: str | None = Field(None, alias="chatId")
    message_id: str | None = Field(None, alias="messageId")


class CompanyAcronymDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["company.acronym"]
    )
    acronym: str = Field(..., description="The acronym abbreviation", examples=["AI"])
    text: str = Field(
        ...,
        description="The full text that the acronym represents",
        examples=["Artificial Intelligence"],
    )


class ChunkCreateInputDto(BaseModel):
    text: str
    model: str | None = None
    start_page: float | None = Field(None, alias="startPage")
    end_page: float | None = Field(None, alias="endPage")
    order: float | None = None
    embedding: list[str] | None = None


class ChunkCreateDto(BaseModel):
    input: ChunkCreateInputDto
    content_id: str = Field(..., alias="contentId")
    chat_id: str | None = Field(None, alias="chatId")


class PublicChunkCreateMutationDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the chunk", examples=["chunk_123456789"]
    )
    object: str = Field(..., description="Object type identifier", examples=["chunk"])
    text: str = Field(
        ...,
        description="Text content of the chunk",
        examples=["This is the text content of the chunk."],
    )
    content_id: str = Field(
        ...,
        alias="contentId",
        description="ID of the content this chunk belongs to",
        examples=["content_987654321"],
    )
    updated_at: datetime = Field(
        ...,
        alias="updatedAt",
        description="Date when the chunk was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )
    created_at: datetime = Field(
        ...,
        alias="createdAt",
        description="Date when the chunk was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    start_page: dict[str, Any] | None = Field(
        None,
        alias="startPage",
        description="Starting page number in the source document",
        examples=[5],
    )
    end_page: dict[str, Any] | None = Field(
        None,
        alias="endPage",
        description="Ending page number in the source document",
        examples=[7],
    )
    order: dict[str, Any] | None = Field(
        None, description="Order of the chunk within the content", examples=[1]
    )
    model: dict[str, Any] | None = Field(
        None, description="Model used to process this chunk", examples=["gpt-4"]
    )


class ChunkCreateManyDto(BaseModel):
    input: list[str]
    content_id: str = Field(..., alias="contentId")
    chat_id: str | None = Field(None, alias="chatId")


class LogDetail(BaseModel):
    text: str
    message_id: str | None = Field(None, alias="messageId")


class ActorType(str, Enum):
    user = "USER"
    system = "SYSTEM"
    assistant = "ASSISTANT"
    tool = "TOOL"


class PublicMagicTableLogEntryDto(BaseModel):
    message_id: str | None = Field(None, alias="messageId")
    text: str
    actor_type: ActorType = Field(..., alias="actorType")
    created_at: datetime = Field(..., alias="createdAt")
    details: list[LogDetail] | None = None


class PublicCreateMagicTableCellDto(BaseModel):
    row_order: float = Field(..., alias="rowOrder")
    column_order: float = Field(..., alias="columnOrder")
    text: str
    log_entries: list[PublicMagicTableLogEntryDto] | None = Field(
        None, alias="logEntries", description="LogEntry for the cell update"
    )


class SelectionMethod(str, Enum):
    default = "DEFAULT"
    manual = "MANUAL"


class AgreementStatus(str, Enum):
    match = "MATCH"
    no_match = "NO_MATCH"


class PublicSetMagicTableCellMetaDataDto(BaseModel):
    row_order: float = Field(..., alias="rowOrder")
    column_order: float = Field(..., alias="columnOrder")
    selected: bool | None = None
    selection_method: SelectionMethod | None = Field(None, alias="selectionMethod")
    agreement_status: AgreementStatus | None = Field(None, alias="agreementStatus")


class PublicMagicTableCellDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["magic-table-cell"]
    )
    sheet_id: str = Field(
        ...,
        alias="sheetId",
        description="ID of the sheet this cell belongs to",
        examples=["sheet_123456789"],
    )
    column_order: float = Field(
        ...,
        alias="columnOrder",
        description="Column order/position of the cell",
        examples=[3],
    )
    row_order: float = Field(
        ...,
        alias="rowOrder",
        description="Row order/position of the cell",
        examples=[5],
    )
    row_locked: bool = Field(
        ...,
        alias="rowLocked",
        description="Whether the row containing this cell is locked",
        examples=[False],
    )
    text: str = Field(
        ..., description="Text content of the cell", examples=["Sample cell data"]
    )
    log_entries: list[PublicMagicTableLogEntryDto] | None = Field(
        None, alias="logEntries", description="Log entries associated with this cell"
    )
    meta_data: PublicSetMagicTableCellMetaDataDto | None = Field(
        None, alias="metaData", description="Metadata associated with this cell"
    )


class PublicMagicTableRowDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["magic-table-row"]
    )
    sheet_id: str = Field(
        ...,
        alias="sheetId",
        description="ID of the sheet this row belongs to",
        examples=["sheet_123456789"],
    )
    row_order: float | None = Field(
        None, alias="rowOrder", description="Order/position of the row", examples=[5]
    )
    row_locked: bool | None = Field(
        None,
        alias="rowLocked",
        description="Whether the row is locked for editing",
        examples=[False],
    )


class Activity(str, Enum):
    delete_row = "DeleteRow"
    delete_column = "DeleteColumn"
    update_cell = "UpdateCell"
    add_question_text = "AddQuestionText"
    add_meta_data = "AddMetaData"
    generate_artifact = "GenerateArtifact"


class Status(str, Enum):
    in_progress = "IN_PROGRESS"
    completed = "COMPLETED"
    failed = "FAILED"


class PublicMagicTableActivityDto(BaseModel):
    activity: Activity
    status: Status
    text: str


class ArtifactType(str, Enum):
    questions = "QUESTIONS"
    full_report = "FULL_REPORT"


class PublicMagicTableArtifactDto(BaseModel):
    name: str | None = None
    content_id: str = Field(..., alias="contentId")
    mime_type: str | None = Field(None, alias="mimeType")
    artifact_type: ArtifactType = Field(..., alias="artifactType")


class State(str, Enum):
    stopped_by_user = "STOPPED_BY_USER"
    processing = "PROCESSING"
    idle = "IDLE"


class PublicUpdateMagicTableSheetDto(BaseModel):
    name: str | None = None
    state: State | None = None


class PublicMagicTableSheetDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["magic-table-sheet"]
    )
    sheet_id: str = Field(
        ...,
        alias="sheetId",
        description="Unique identifier for the magic table sheet",
        examples=["sheet_123456789"],
    )
    name: str = Field(
        ...,
        description="Name of the magic table sheet",
        examples=["Data Analysis Sheet"],
    )
    state: State = Field(
        ..., description="Current state of the magic table sheet", examples=["ACTIVE"]
    )
    chat_id: str = Field(
        ...,
        alias="chatId",
        description="ID of the chat this sheet belongs to",
        examples=["chat_987654321"],
    )
    created_by: str = Field(
        ...,
        alias="createdBy",
        description="ID of the user who created the sheet",
        examples=["user_456789123"],
    )
    company_id: str = Field(
        ...,
        alias="companyId",
        description="ID of the company this sheet belongs to",
        examples=["company_789123456"],
    )
    created_at: datetime = Field(
        ...,
        alias="createdAt",
        description="Date when the sheet was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    magic_table_cells: list[PublicMagicTableCellDto] | None = Field(
        None,
        alias="magicTableCells",
        description="Cells contained in the magic table sheet",
    )
    magic_table_row_count: float = Field(
        ...,
        alias="magicTableRowCount",
        description="Total number of rows in the magic table",
        examples=[25],
    )


class PublicSetMagicTableColumnMetaDataDto(BaseModel):
    column_order: float = Field(..., alias="columnOrder")
    column_width: float | None = Field(None, alias="columnWidth")
    cell_renderer: str | None = Field(None, alias="cellRenderer")
    filter: str | None = None
    editable: bool | None = None


class PublicMessageAssessmentCreateDto(BaseModel):
    status: str
    message_id: str = Field(..., alias="messageId")
    explanation: str | None = None
    label: str | None = None
    type: str | None = None
    is_visible: bool | None = Field(None, alias="isVisible")


class PublicMessageAssessmentDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(
        ..., description="Object type identifier", examples=["message-assessment"]
    )
    message_assessment_id: dict[str, Any] | None = Field(
        ...,
        alias="messageAssessmentId",
        description="Unique identifier for the message assessment",
        examples=["assessment_123456789"],
    )
    message_id: dict[str, Any] | None = Field(
        ...,
        alias="messageId",
        description="ID of the message being assessed",
        examples=["message_987654321"],
    )
    status: dict[str, Any] | None = Field(
        ..., description="Status of the assessment", examples=["approved"]
    )
    explanation: dict[str, Any] | None = Field(
        ...,
        description="Explanation for the assessment",
        examples=["This message provides accurate information."],
    )
    label: dict[str, Any] | None = Field(
        ..., description="Label assigned to the assessment", examples=["quality_check"]
    )
    type: dict[str, Any] | None = Field(
        ..., description="Type of assessment", examples=["manual"]
    )
    is_visible: dict[str, Any] | None = Field(
        ...,
        alias="isVisible",
        description="Whether the assessment is visible",
        examples=[True],
    )
    created_at: dict[str, Any] | None = Field(
        ...,
        alias="createdAt",
        description="Date when the assessment was created",
        examples=["2023-12-06T10:00:00Z"],
    )
    updated_at: dict[str, Any] | None = Field(
        ...,
        alias="updatedAt",
        description="Date when the assessment was last updated",
        examples=["2023-12-06T15:30:00Z"],
    )


class PublicMessageAssessmentUpdateDto(BaseModel):
    type: str
    status: str | None = None
    explanation: str | None = None
    label: str | None = None
    is_visible: bool | None = Field(None, alias="isVisible")


class PublicCreateFolderDto(BaseModel):
    paths: list[str] = Field(
        ...,
        description="An array of paths to validate",
        examples=[["/path/to/folder", "/another-folder"]],
    )


class FolderDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(..., description="Object type identifier", examples=["object"])
    name: str = Field(
        ..., description="The name of the scope", examples=["Folder Name"]
    )
    parent_id: dict[str, Any] | None = Field(
        ...,
        alias="parentId",
        description="The ID of the parent scope",
        examples=["scope_fctg9an96pixkij6da9rwaiw"],
    )


class PublicCreateFolderResultDto(BaseModel):
    created_folders: list[FolderDto] = Field(
        ...,
        alias="createdFolders",
        description="Array of created folder objects",
        examples=[
            {
                "createdFolders": [
                    {
                        "id": "scope_xfhctalrzdt161p3t9biojux",
                        "object": "createFolderStructureResponse",
                        "name": "folder",
                        "parentId": "scope_vs8hevypj5eaob5hdm693g10",
                    },
                    {
                        "id": "scope_sn6u2qrxgpn9kp7ncfr3sn7t",
                        "object": "createFolderStructureResponse",
                        "name": "another-folder",
                        "parentId": None,
                    },
                ]
            }
        ],
    )


class EntityType(str, Enum):
    group = "GROUP"
    user = "USER"


class Type1(str, Enum):
    read = "READ"
    write = "WRITE"


class ScopeAccessDto(BaseModel):
    id: str = Field(
        ..., description="Unique identifier for the object", examples=["obj_123456789"]
    )
    object: str = Field(..., description="Object type identifier", examples=["object"])
    entity_id: str = Field(..., alias="entityId", description="Id of the Scope Access")
    entity_type: EntityType = Field(
        ..., alias="entityType", description="Type of the Scope Access Entity"
    )
    type: Type1 = Field(..., description="Type of the Scope Access")


class AddScopeAccessDto(BaseModel):
    scope_accesses: list[ScopeAccessDto] = Field(
        ...,
        alias="scopeAccesses",
        description="Scope accesses to add to the folder and its subfolders.",
    )
    apply_to_sub_scopes: bool = Field(
        False,
        alias="applyToSubScopes",
        description="If true, the scope access will be added to all subfolders.",
    )


class ChildrenScope(BaseModel):
    id: str = Field(..., description="The id of the scope.")
    name: str = Field(..., description="The name of the scope.")


class PublicUpdateFolderAccessResultDto(BaseModel):
    id: str = Field(
        ...,
        description="The id of the folder whose access was updated.",
        examples=["obj_123456789"],
    )
    object: str = Field(..., description="Object type identifier", examples=["object"])
    name: str = Field(
        ..., description="The name of the folder whose access was updated."
    )
    scope_accesses: list[ScopeAccessDto] = Field(
        ..., alias="scopeAccesses", description="Scope accesses of the folder."
    )
    children: list[ChildrenScope] = Field(..., description="Subfolders of the folder.")


class DeleteScopeAccessDto(BaseModel):
    scope_accesses: list[str] = Field(
        ...,
        alias="scopeAccesses",
        description="Scope accesses to add to the folder and its subfolders.",
    )
    apply_to_sub_scopes: bool = Field(
        False,
        alias="applyToSubScopes",
        description="If true, the scope access will be removed from all subfolders.",
    )


class UpdateFolderIngestionConfigDto(BaseModel):
    ingestion_config: IngestionConfigDto = Field(
        ...,
        alias="ingestionConfig",
        description="Ingestion config for the folder",
        examples=[
            {
                "ingestionConfig": {
                    "chunkMaxTokens": 1000,
                    "chunkMaxTokensOnePager": 500,
                    "chunkMinTokens": 100,
                }
            }
        ],
    )
    apply_to_sub_scopes: bool = Field(
        False,
        alias="applyToSubScopes",
        description="If true, the scope access will be added to all subfolders.",
    )


class ChatRequestAssistantMessage(RootModel[Any]):
    root: Any


class ChatRequestFunctionMessage(RootModel[Any]):
    root: Any


class ChatRequestSystemMessage(RootModel[Any]):
    root: Any


class ChatRequestToolMessage(RootModel[Any]):
    root: Any


class ChatRequestUserMessage(RootModel[Any]):
    root: Any


class PublicCreateChatCompletionDto(BaseModel):
    model: str | None = None
    timeout: float | None = None
    messages: list[
        ChatRequestSystemMessage
        | ChatRequestUserMessage
        | ChatRequestAssistantMessage
        | ChatRequestToolMessage
        | ChatRequestFunctionMessage
    ]
    options: GetChatCompletionsOptions | None = None


class PublicStreamMessageDto(BaseModel):
    model: str | None = None
    timeout: float | None = None
    messages: list[
        ChatRequestSystemMessage
        | ChatRequestUserMessage
        | ChatRequestAssistantMessage
        | ChatRequestToolMessage
        | ChatRequestFunctionMessage
    ]
    chat_id: str = Field(..., alias="chatId")
    assistant_message_id: str = Field(..., alias="assistantMessageId")
    search_context: list[SearchResultDto] | None = Field(
        None,
        alias="searchContext",
        description="Available search results that can be added as references to the message. This happens automatically in case a [source<NUMBER>] is found in the streamed text.",
    )
    user_message_id: str = Field(..., alias="userMessageId")
    start_text: str | None = Field(None, alias="startText")
    debug_info: dict[str, Any] | None = Field(None, alias="debugInfo")
    options: GetChatCompletionsOptions | None = None


NestedStringFilter.model_rebuild()
NestedStringNullableFilter.model_rebuild()
ContentWhereInput.model_rebuild()
