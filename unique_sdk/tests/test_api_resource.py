from unittest.mock import AsyncMock, Mock, patch

import pytest

from unique_sdk._api_resource import APIResource
from unique_sdk._error import APIError, InvalidRequestError


# Define a sample concrete subclass to test abstract behavior
class MessageResource(APIResource):
    OBJECT_NAME = "message"

    def __init__(self, user_id="test_user", company_id="test_company"):
        super().__init__(user_id, company_id)

    def get(self, id):
        return self.user_id


@pytest.fixture
def mock_unique_object():
    with patch("unique_sdk._api_resource.UniqueObject") as mock_unique_object:
        mock_unique_object._request.return_value = Mock(return_value={"key": "value"})
        yield mock_unique_object


@pytest.fixture
def mock_api_requestor():
    with patch("unique_sdk._api_resource.APIRequestor") as mock_api_requestor:
        yield mock_api_requestor


@pytest.mark.parametrize("resource_id", ["abc123", "xyz789"])
def test_instance_url_valid_id(resource_id):
    # Set up a resource instance with a valid ID
    resource = MessageResource(user_id=resource_id)

    # Generate the expected instance URL
    expected_url = f"/messages/{resource_id}"

    # Assert the URL generated by `instance_url` matches the expected value
    assert resource.instance_url() == expected_url


def test_instance_url_invalid_id(mock_unique_object):
    # Set up a resource instance with no ID
    resource = MessageResource(user_id=None)
    resource.get = Mock(return_value=None)

    # Expect an InvalidRequestError
    with pytest.raises(InvalidRequestError):
        resource.instance_url()


def test_class_url_on_base_class():
    # Try to call class_url on base APIResource, which should raise an error
    with pytest.raises(NotImplementedError):
        APIResource.class_url()


def test_class_url_on_subclass():
    # Ensure the subclass generates the correct class URL
    expected_url = "/messages"
    assert MessageResource.class_url() == expected_url


@pytest.mark.parametrize("method", ["get", "post", "delete"])
@patch.object(MessageResource, "refresh_from")
def test_request_and_refresh_sync(refresh_from_mock, mock_unique_object, method):
    # Set up a resource instance
    resource = MessageResource()
    # resource.refresh_from = Mock()

    # Mock the _request method of UniqueObject
    mock_response = {"key": "value"}
    mock_unique_object._request.return_value = mock_response

    # Perform the request and refresh
    refreshed_resource = resource._request_and_refresh(
        method, "/messages/abc123", "user_1", "company_1"
    )

    # Verify refresh_from was called and the correct object was returned
    refresh_from_mock.assert_called_once_with(mock_response, "user_1", "company_1")
    assert refreshed_resource is resource


@pytest.mark.parametrize("method", ["get", "post", "delete"])
@pytest.mark.asyncio
@patch.object(MessageResource, "refresh_from")
async def test_request_and_refresh_async(refresh_from_mock, mock_unique_object, method):
    # Set up a resource instance
    resource = MessageResource()

    # Mock the _request_async method of UniqueObject
    mock_response = {"key": "value"}
    mock_unique_object._request_async = AsyncMock(return_value=mock_response)

    # Perform the async request and refresh
    refreshed_resource = await resource._request_and_refresh_async(
        method, "/messages/abc123", "user_1", "company_1"
    )

    # Verify refresh_from was called and the correct object was returned
    refresh_from_mock.assert_called_once_with(mock_response, "user_1", "company_1")
    assert refreshed_resource is resource


def test_static_request_success(mock_api_requestor):
    # Mock APIRequestor's request method
    mock_response = {"key": "value"}
    mock_api_requestor.return_value.request.return_value = mock_response

    # Perform a static request
    MessageResource._static_request("get", "/messages", "user_1", "company_1")

    # Verify the request was made and the response was converted
    mock_api_requestor.return_value.request.assert_called_once_with(
        "get", "/messages", None
    )
    # Mocked response should be passed to the convert_to_unique_object function


@pytest.mark.asyncio
async def test_static_request_async_success(mock_api_requestor):
    # Mock APIRequestor's async request method
    mock_response = Mock()
    mock_api_requestor.return_value.request_async = AsyncMock(
        return_value=mock_response
    )

    # Perform an async static request
    await MessageResource._static_request_async(
        "get", "/messages", "user_1", "company_1"
    )

    # Verify the async request was made
    mock_api_requestor.return_value.request_async.assert_called_once_with(
        "get", "/messages", None
    )
    # Mocked response should be passed to the convert_to_unique_object function


@pytest.mark.asyncio
@patch("asyncio.sleep", return_value=None)
async def test_static_request_async_retry_on_specific_error(
    mock_asyncio_sleep, mock_api_requestor
):
    mock_api_requestor.return_value.request_async.side_effect = APIError(
        "There was a problem proxying the request"
    )
    with pytest.raises(APIError, match="Failed after 3 attempts"):
        await MessageResource._static_request_async(
            "get", "/messages", "user_1", "company_1"
        )
    assert (
        mock_api_requestor.return_value.request_async.call_count == 3
    )  # Ensure it retries 3 times
    assert mock_asyncio_sleep.call_count == 2


@pytest.mark.asyncio
@patch("asyncio.sleep", return_value=None)
async def test_static_request_async_retry_on_specific_error_second(
    mock_asyncio_sleep, mock_api_requestor
):
    mock_api_requestor.return_value.request_async.side_effect = APIError(
        "Upstream service reached a hard timeout"
    )
    with pytest.raises(APIError, match="Failed after 3 attempts"):
        await MessageResource._static_request_async(
            "get", "/messages", "user_1", "company_1"
        )
    assert (
        mock_api_requestor.return_value.request_async.call_count == 3
    )  # Ensure it retries 3 times
    assert mock_asyncio_sleep.call_count == 2


@pytest.mark.asyncio
async def test_static_request_async_no_retry_on_different_error(mock_api_requestor):
    mock_api_requestor.return_value.request_async.side_effect = ConnectionError(
        "Some other error"
    )
    with pytest.raises(ConnectionError, match="Some other error"):
        await MessageResource._static_request_async(
            "get", "/messages", "user_1", "company_1"
        )
    assert (
        mock_api_requestor.return_value.request_async.call_count == 1
    )  # Ensure it does not retry


@patch("time.sleep", return_value=None)
def test_static_request_sync_retry_on_specific_error(mock_sleep, mock_api_requestor):
    mock_api_requestor.return_value.request.side_effect = APIError(
        "There was a problem proxying the request"
    )
    with pytest.raises(APIError, match="Failed after 3 attempts"):
        MessageResource._static_request("get", "/messages", "user_1", "company_1")
    assert (
        mock_api_requestor.return_value.request.call_count == 3
    )  # Ensure it retries 3 times
    assert mock_sleep.call_count == 2


@patch("time.sleep", return_value=None)
def test_static_request_sync_retry_on_specific_error_second(
    mock_sleep, mock_api_requestor
):
    mock_api_requestor.return_value.request.side_effect = APIError(
        "Upstream service reached a hard timeout"
    )
    with pytest.raises(APIError, match="Failed after 3 attempts"):
        MessageResource._static_request("get", "/messages", "user_1", "company_1")
    assert (
        mock_api_requestor.return_value.request.call_count == 3
    )  # Ensure it retries 3 times
    assert mock_sleep.call_count == 2


def test_static_request_sync_no_retry_on_different_error(mock_api_requestor):
    mock_api_requestor.return_value.request.side_effect = ConnectionError(
        "Some other error"
    )
    """Test sync request doesn't retry on different error message."""
    with pytest.raises(ConnectionError, match="Some other error"):
        MessageResource._static_request("get", "/messages", "user_1", "company_1")
    assert (
        mock_api_requestor.return_value.request.call_count == 1
    )  # Ensure it does not retry


def test_request(mock_unique_object):
    # Mock the synchronous request method
    resource = MessageResource()
    mock_response = Mock()
    mock_unique_object._request.return_value = mock_response

    # Call the method
    resource._request("get", "/messages/abc123", "user_1", "company_1")

    # Ensure _request was called and the resource was refreshed
    mock_unique_object._request.assert_called_once_with(
        resource, "get", "/messages/abc123", "user_1", "company_1", None, None
    )


@pytest.mark.asyncio
async def test_request_async(mock_unique_object):
    # Mock the asynchronous request method
    resource = MessageResource()
    mock_response = Mock()
    mock_unique_object._request_async = AsyncMock(return_value=mock_response)

    # Call the method
    await resource._request_async("get", "/messages/abc123", "user_1", "company_1")

    # Ensure _request_async was called and the resource was refreshed
    mock_unique_object._request_async.assert_called_once_with(
        resource, "get", "/messages/abc123", "user_1", "company_1", None, None
    )
